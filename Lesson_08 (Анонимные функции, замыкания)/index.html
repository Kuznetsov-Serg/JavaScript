<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>HomeWork_08</title>
</head>

<body>
    <script>
        /****************************************************************************
        <!-- Lesson_08 - Анонимные функции, замыкания
        1.	 Для практикума из занятия 7 продумать, где можно применить замыкания.
            Ответ:
                Он уже применен НЕ единожды при вызове значений и методов внешних объектов по отношению к 
                объекту game (config, map, snake, food, antiFood) и т.д. см. http://e99920zb.beget.tech/snake.html

        2.	 Не выполняя кода, ответить, что выведет браузер и почему:
        a)  if (!("a" in window)) {
                var a = 1;
            }
            alert(a);
            Ответ: 
                "a" определна глобально, т.е. имеется в window. Отрицание "!"" не позволит присвоить "a" значение "1".
                Соответственно, alert выдаст "undefined"
        b)  var b = function a(x) {
                x && a(--x);
            };
            alert(a);
            Ответ:
                Это функциональное выражение и название функции "a" в этом случае доступно только внутри тела функции "a".
                Соответственно, в консоли выдаст: "a is not defined"
        c)  function a(x) {
                return x * 2;
            }
            var a;
            alert(a);
            Ответ:
                Сначала я подумал, что JS имеет динамическое перепределение типов. Для имени "a" будет действовать последнее объявление.
                Учитывая то, что мы не определили его значение, выдаст "undefined".
                Но, потом перечитал методичку: "кода браузер в первую очередь производит поиск объявлений функций. 
                Когда обнаруживает, создается функция и переменной, у которой имя будет совпадать с именем функции, 
                присваивается ссылка на функцию...." 
                Получается, что пока мы принудительно не переприсвоили "a" к.л. значение, это имя указывает на функцию!!!
        d)  function b(x, y, a) {
                arguments[2] = 10;
                alert(a);
            }
            b(1, 2, 3);
            Ответ:
                Зависит от режима исполнения JS:
                -   В строгом режиме "use strict" нельзя выполнять операции присваивания значений таким сущностям, 
                    предназначенным только для чтения, как arguments,... Alert вернет "3".
                -   В нестрогом, JS позволит переопределить значение вх. аргумента и Alert вернет "10".
        e)  function a() {
                alert(this);
            }
            a.call(null); 
            Ответ:
                Зависит от режима исполнения JS:
                -   в строгом режиме "use strict" вернет "null" 
                -   в НЕстрогом режиме, если первый аргумент call или apply — null или undefined, то значение this 
                    выполняемой функции будет преобразование в глобальный объект (для браузеров это window)
                Естественно, если мы в call поместим "нормальный" контекст, он его предоставит при любом режиме исполнения!

        3. Сделать функции каррирования:
          // console.log(sum(a)(b)...(n)()); // => a + b + ... + n
          // console.log(sum(a)(b)...(n)); // => a + b + ... + n
        ****************************************************************/
        'use strict';

        // Сначала нашел и разобрался с достаточо "понятной" функцией для обработки выражения 
        // console.log(sum(a)(b)...(n)()); // => a + b + ... + n
        /*
        *   fn - функция для двух аргументов
        *   seed - начальное значение для первого аргумента функции, не влияющее на результат (0 + a = a или 1 * a = a)
        */
        const infiniteCurry = (fn, seed) => {
            const reduceValue = (args, seedValue) =>        // работа с одним списком параметров, к примеру (2, 5, 7)
                args.reduce((acc, a) => {                   // применить к каждому элементу списка функцию fn
                    return fn.call(fn, acc, a);
                }, seedValue);
            const next = (...args) => {
                return (...x) => {                          // перебор списков аргументов x=(1), x=(2, 7), x=(9, 10,3)...
                    if (!x.length) {                        // () - пустой элемент, завершаем разбор аргументов
                        return reduceValue(args, seed);     // возвращаем результат вычисления суммы/произведения консолидированных 
                    }                                       // на более ранних стадиях аргументов (1, 10, 19)
                    return next(...args, reduceValue(x, seed));     // иначе, возвращаем функцию, добавляя в список аргументов результат 
                };                                                  // вычисления очередного списка параметров (2, 7) -->  "9"
            };
            return next();
        };

        const iSum = infiniteCurry((x, y) => x + y, 0);
        const iMul = infiniteCurry((x, y) => x * y, 1);
        console.log(iSum(1)(3, 4)(5, 6)(7, 8, 9)()); // 43
        console.log(iMul(1)(3, 4)(5, 6)()); // 360

        // Естественно, все это уже не работает с выражениями типа:
        // console.log(sum(a)(b)...(n)); // => a + b + ... + n
        // Тогда наткнулся на пример, разобранный ниже. Код прекрасно справляется с обоими вариантами выражений.

        function sum(...params) {
            var s = params.reduce((a, b) => a + b);

            function innerSum(...innerParams) {
                return sum(...innerParams.concat(s));
            };
            innerSum.toString = innerSum.valueOf = function () {
                return s;
            }
            return innerSum;
        }

        console.log(+sum(1, 2)(3, 4)(5, 6)());
        console.log(sum(1, 2)(3, 4)(5, 6)());
        console.log(sum(1)(2)(3)(4)(5)(6)); // все еще работает
        console.log(sum(1)(2, 3)(4, 5, 6));

    </script>
</body>

</html>